{# templates/noticias/timeline_fragment.html #}
{% load vote_extras %}

<div id="timeline-container" class="max-w-3xl mx-auto mono" 
     data-should-show-signup="{{ should_show_signup_prompt|yesno:'true,false' }}"
     data-total-votes="{{ total_votes_count|default:0 }}">
  <!-- Notification area -->
  <div id="notification-area" class="fixed top-20 right-4 z-50 max-w-md"></div>

  <!-- Extension Banner (dismissible) -->
  <div id="extension-banner" class="bg-black text-white border-2 border-black p-4 mb-4" x-data="{ show: !localStorage.getItem('extensionBannerDismissed') }" x-show="show" x-transition>
    <div class="flex items-start justify-between gap-4">
      <div class="flex-1">
        <div class="flex items-center gap-2 mb-2">
          <span class="text-xl">üöÄ</span>
          <h3 class="font-bold text-sm md:text-base">
            Instal√° la extensi√≥n de Chrome
          </h3>
        </div>
        <p class="text-xs md:text-sm text-gray-300 mb-3 leading-relaxed">
          Vot√° noticias directamente desde cualquier sitio uruguayo.
          Un click mientras le√©s ‚Üí tu voto queda registrado.
        </p>
        <div class="flex flex-wrap gap-2">
          <a href="https://chromewebstore.google.com/detail/mioieljgilldgicjdjokmobikkflphbk"
             target="_blank"
             rel="noopener noreferrer"
             class="inline-block bg-white text-black px-4 py-2 text-xs font-bold hover:bg-gray-200 transition-colors border border-white">
            Instalar extensi√≥n ‚Üí
          </a>
          <a href="{% url 'bienvenida' %}"
             class="inline-block border border-white text-white px-4 py-2 text-xs hover:bg-white hover:text-black transition-colors">
            Ver c√≥mo funciona
          </a>
        </div>
      </div>
      <button @click="show = false; localStorage.setItem('extensionBannerDismissed', 'true')"
              class="text-white hover:text-gray-300 text-xl leading-none"
              aria-label="Cerrar">
        √ó
      </button>
    </div>
  </div>

  <!-- Hero / Value Prop -->
  <div class="border-0 border-black bg-white p-4 mb-4">
    <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
      <div class="flex-1 min-w-0">
        <h2 class="text-lg md:text-xl font-bold mb-2">
          Vot√° noticias. Descubr√≠ patrones. Sal√≠ de tu burbuja.
        </h2>
        <p class="text-xs md:text-sm text-gray-700">
          Vot√° an√≥nimamente y explor√° c√≥mo votan otras burbujas. Sin registro. Sin seguimiento.
        </p>
      </div>
      <button onclick="shareTimeline()"
              class="hidden md:flex flex-shrink-0 border-2 border-black px-4 py-2.5 hover:bg-black hover:text-white transition-all text-xs mono font-bold items-center gap-2"
              title="Compartir timeline en WhatsApp">
        <span class="text-base">üí¨</span>
        <span>compartir</span>
      </button>
    </div>
  </div>

  <!-- Filter bar -->
  <div x-data="{
    openFilters: false,
    primaryFilter: {% if current_filter == 'todas' %}'todas'{% elif current_filter == 'nuevas' or not current_filter %}'nuevas'{% elif current_filter in 'buena_mi,buena_mayoria,cluster_consenso_buena' %}'buenas'{% elif current_filter in 'mala_mi,mala_mayoria' %}'malas'{% elif current_filter in 'mencionan_a,mencionan_positiva,mencionan_negativa' %}''{% else %}'nuevas'{% endif %},
    perspective: {% if current_filter in 'buena_mi,mala_mi' %}'mi'{% elif current_filter == 'cluster_consenso_buena' %}'burbuja'{% elif current_filter in 'buena_mayoria,mala_mayoria' %}'mayoria'{% else %}'mi'{% endif %},
    entity: '{% if request.GET.entidad %}{{ request.GET.entidad }}{% endif %}',
    showPerspectiveSelector() {
      return this.primaryFilter === 'buenas' || this.primaryFilter === 'malas';
    },
    clearEntityFilter() {
      this.entity = '';
    },
    clearPrimaryFilter() {
      this.primaryFilter = '';
      this.perspective = 'mi';
    }
  }" class="border-2 border-black bg-white mb-4">

    <!-- Filter header -->
    <div class="p-3 border-b-2 border-black bg-gray-50">
      <div class="flex justify-between items-center">
        <h3 class="font-bold flex items-center text-xs">
          <span class="mr-2">‚ñ∂</span> filtrar noticias
        </h3>
        <button @click="openFilters = !openFilters"
                class="border border-black px-2 py-1 text-[10px] hover:bg-black hover:text-white transition-colors">
          <span x-show="!openFilters">[mostrar]</span>
          <span x-show="openFilters">[ocultar]</span>
        </button>
      </div>

      <!-- Active filter indicator -->
      <div id="active-filter-text" class="mt-2 text-[10px] text-gray-600">
        > {{ filter_description|default:"sin filtros activos" }}
      </div>
    </div>

    <!-- Filter options (collapsible) -->
    <div x-show="openFilters" x-transition class="p-3 bg-white space-y-4">

      <!-- Primary filters -->
      <div>
        <h4 class="text-[10px] text-gray-600 mb-2">// filtro principal</h4>
        <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
          <button @click="primaryFilter = 'todas'; clearEntityFilter(); trackEvent('filter-change', {filter: 'todas'});"
                  hx-get="{% url 'timeline' %}?filter=todas"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="primaryFilter === 'todas' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-1.5 transition-colors text-xs">
            todas las noticias
          </button>
          <button @click="primaryFilter = 'nuevas'; clearEntityFilter(); trackEvent('filter-change', {filter: 'nuevas'});"
                  hx-get="{% url 'timeline' %}?filter=nuevas"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="primaryFilter === 'nuevas' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-1.5 transition-colors text-xs">
            noticias nuevas
          </button>
          <button @click="primaryFilter = 'buenas'; perspective = 'mi'; clearEntityFilter(); trackEvent('filter-change', {filter: 'buena_mi'});"
                  hx-get="{% url 'timeline' %}?filter=buena_mi"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="primaryFilter === 'buenas' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-1.5 transition-colors text-xs">
            üòä buenas noticias
          </button>
          <button @click="primaryFilter = 'malas'; perspective = 'mi'; clearEntityFilter(); trackEvent('filter-change', {filter: 'mala_mi'});"
                  hx-get="{% url 'timeline' %}?filter=mala_mi"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="primaryFilter === 'malas' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-1.5 transition-colors text-xs">
            üòû malas noticias
          </button>
        </div>
      </div>

      <!-- Perspective selector (shown only when buenas/malas selected) -->
      <div x-show="showPerspectiveSelector()" x-transition class="pb-4 border-b border-gray-300">
        <h4 class="text-[10px] text-gray-600 mb-2">// seg√∫n qui√©n?</h4>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
          <button @click="perspective = 'mi'; clearEntityFilter()"
                  x-bind:hx-get="'{% url 'timeline' %}?filter=' + (primaryFilter === 'buenas' ? 'buena' : 'mala') + '_mi'"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="perspective === 'mi' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-2 transition-colors text-xs">
            <div class="font-bold">mi opini√≥n</div>
            <div class="text-[9px] text-gray-600">seg√∫n lo que vot√©</div>
          </button>
          <button @click="perspective = 'burbuja'; clearEntityFilter()"
                  hx-get="{% url 'timeline' %}?filter=cluster_consenso_buena"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="perspective === 'burbuja' ? 'bg-blue-600 text-white' : 'hover:bg-blue-600 hover:text-white'"
                  class="border-2 border-blue-600 px-3 py-2 transition-colors text-xs {% if not has_cluster %}opacity-50 cursor-not-allowed{% endif %}"
                  {% if not has_cluster %}disabled{% endif %}>
            <div class="font-bold">mi burbuja</div>
            <div class="text-[9px] text-gray-600">seg√∫n votantes similares</div>
          </button>
          <button @click="perspective = 'mayoria'; clearEntityFilter()"
                  x-bind:hx-get="'{% url 'timeline' %}?filter=' + (primaryFilter === 'buenas' ? 'buena' : 'mala') + '_mayoria'"
                  hx-target="#timeline-items"
                  hx-swap="innerHTML"
                  hx-indicator="#timeline-skeleton-container"
                  hx-push-url="true"
                  :class="perspective === 'mayoria' ? 'bg-black text-white' : 'hover:bg-black hover:text-white'"
                  class="border-2 border-black px-3 py-2 transition-colors text-xs">
            <div class="font-bold">la mayor√≠a</div>
            <div class="text-[9px] text-gray-600">seg√∫n todos los votos</div>
          </button>
        </div>
        <p id="no-cluster-message" class="text-[9px] text-gray-500 mt-2" {% if has_cluster %}style="display: none;"{% endif %}>
          * La opci√≥n "mi burbuja" estar√° disponible cuando se genere el pr√≥ximo an√°lisis de clusters
        </p>
      </div>

      <!-- Entity filters (dynamically updated) -->
      <div>
        {% include "noticias/entity_filter.html" %}
      </div>
    </div>
  </div>

  <!-- Timeline Items -->
  <div id="timeline-items" class="relative" hx-indicator="#timeline-skeleton-container">
    {% include "noticias/timeline_items.html" %}
    
    <!-- Skeleton screens container (shown during loading) -->
    <div id="timeline-skeleton-container" class="htmx-indicator absolute inset-0 pointer-events-none bg-white bg-opacity-95">
      <div class="max-w-3xl mx-auto">
        {% for i in "123" %}
        {% include "noticias/timeline_skeleton.html" %}
        {% endfor %}
      </div>
    </div>
  </div>

  <!-- Floating share button (mobile only) -->
  <button onclick="shareTimeline()"
          class="md:hidden fixed bottom-6 right-6 z-50 bg-green-600 text-white rounded-full w-16 h-16 shadow-[0_4px_12px_rgba(0,0,0,0.3)] hover:bg-green-700 active:bg-green-800 transition-all flex items-center justify-center text-3xl"
          title="Compartir en WhatsApp"
          aria-label="Compartir timeline">
    üí¨
  </button>
</div>

<!-- Styles -->
<style>
  /* HTMX indicator handling */
  .htmx-indicator {
    display: none;
  }
  .htmx-request .htmx-indicator {
    display: flex;
  }
  .htmx-request.htmx-indicator {
    display: flex;
  }

  /* Form input styling */
  input[type="url"],
  input[type="text"] {
    width: 100%;
    border: 2px solid black;
    padding: 0.75rem;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.875rem;
    background: white;
  }

  input[type="url"]:focus,
  input[type="text"]:focus {
    outline: none;
    background-color: #f9f9f9;
  }

  /* Select styling */
  select {
    font-family: 'IBM Plex Mono', monospace;
  }

  /* Signup prompt animation */
  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Vote confirmation animation */
  @keyframes voteConfirm {
    0% {
      opacity: 0;
      transform: scale(0.8);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  .vote-checkmark {
    animation: voteConfirm 0.3s ease-out;
  }

  /* Skeleton loading animation */
  @keyframes shimmer {
    0% {
      background-position: -1000px 0;
    }
    100% {
      background-position: 1000px 0;
    }
  }

  .skeleton {
    background: linear-gradient(
      90deg,
      #f0f0f0 0px,
      #e0e0e0 40px,
      #f0f0f0 80px
    );
    background-size: 1000px 100%;
    animation: shimmer 1.5s infinite;
    border-radius: 2px;
  }

  /* Show skeleton during loading */
  #timeline-skeleton-container {
    display: none;
    z-index: 10;
    background: rgba(255, 255, 255, 0.95);
  }

  /* Show skeleton when HTMX is requesting */
  .htmx-request #timeline-skeleton-container,
  #timeline-items.htmx-request #timeline-skeleton-container {
    display: block;
  }

  /* Ensure skeleton doesn't block interactions */
  #timeline-skeleton-container {
    pointer-events: none;
  }
  
  #timeline-skeleton-container * {
    pointer-events: none;
  }

  /* Floating share button animation */
  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    50% {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }
  }

  button[onclick="shareTimeline()"].md\:hidden {
    animation: pulse 2s ease-in-out infinite;
  }

  button[onclick="shareTimeline()"].md\:hidden:active {
    animation: none;
    transform: scale(0.92);
  }

  /* Ensure button doesn't overlap with content on very small screens */
  @media (max-width: 640px) {
    button[onclick="shareTimeline()"].md\:hidden {
      bottom: 1rem;
      right: 1rem;
      width: 3.5rem;
      height: 3.5rem;
      font-size: 1.5rem;
    }
  }
</style>

<!-- JavaScript -->
<script>
  // Extension session synchronization
  console.log('[Memoria Web] Checking for extension session in localStorage...');

  const extensionSessionId = localStorage.getItem('memoria_extension_session');

  if (extensionSessionId) {
    console.log('[Memoria Web] ‚úì Found extension session:', extensionSessionId);
    
    // Track extension usage
    trackEvent('extension-detected', {
      has_session: true
    });

    document.body.addEventListener('htmx:configRequest', function(event) {
      event.detail.headers['X-Extension-Session'] = extensionSessionId;
    });
  } else {
    console.log('[Memoria Web] No extension session found, using Django session');
    
    // Track that extension is not being used
    trackEvent('extension-detected', {
      has_session: false
    });
  }

  // Notification system
  function showNotification(message, type) {
    const notificationArea = document.getElementById('notification-area');
    const notification = document.createElement('div');

    let bgClass = type === 'error' ? 'bg-red-50' : 'bg-green-50';

    notification.className = `border-2 border-black ${bgClass} px-4 py-3 shadow-lg mb-3 mono text-sm`;
    notification.innerHTML = `
      <div class="flex items-center justify-between">
        <div>
          <span class="mr-2">${type === 'error' ? '‚úó' : '‚úì'}</span>
          <span>${message}</span>
        </div>
        <button type="button" class="ml-4 text-xl" onclick="this.parentNode.parentNode.remove()">
          √ó
        </button>
      </div>
    `;

    notificationArea.appendChild(notification);
    setTimeout(() => notification.remove(), 5000);
  }

  // Event listeners
  document.body.addEventListener('noticiaCreated', function(event) {
    showNotification(event.detail.message, 'success');
  });

  document.body.addEventListener('noticiaError', function(event) {
    showNotification(event.detail.message, 'error');
  });

  document.addEventListener('htmx:responseError', function(event) {
    let errorMessage = 'error en la solicitud';
    try {
      const xhr = event.detail.xhr;
      if (xhr.status === 400 || xhr.status === 500) {
        errorMessage = `error ${xhr.status}`;
      } else if (xhr.status === 404) {
        errorMessage = 'recurso no encontrado';
      }
    } catch (e) {}
    showNotification(errorMessage, 'error');
  });

  document.addEventListener('htmx:sendError', function(event) {
    showNotification('error de conexi√≥n', 'error');
  });

  document.addEventListener('htmx:timeout', function(event) {
    showNotification('timeout: intent√° de nuevo', 'error');
  });

  // Handle swap errors gracefully
  document.body.addEventListener('htmx:swapError', function(event) {
    if (event.detail.target && event.detail.target.id === 'load-more-trigger') {
      event.detail.target.remove();
      checkTimelineState();
    }
  });

  document.body.addEventListener('htmx:beforeSwap', function(event) {
    if (event.detail.target && event.detail.target.id === 'load-more-trigger') {
      var xhr = event.detail.xhr;
      var responseText = xhr.responseText.trim();
      if (!responseText) {
        event.detail.shouldSwap = false;
        event.detail.target.remove();
        checkTimelineState();
      }
    }
  });

  document.body.addEventListener('updateActiveFilters', function(event) {
    const filterText = document.getElementById('active-filter-text');
    if (filterText && event.detail && event.detail.description) {
      filterText.textContent = '> ' + event.detail.description;
    }
  });

  function checkTimelineState() {
    const container = document.getElementById('timeline-items');
    if (!container) return;

    const newsItems = container.querySelectorAll('[id^="noticia-"]');
    const spinner = document.getElementById('load-more-trigger');

    if (newsItems.length === 0 && !spinner) {
      // Check if should show signup prompt
      const timelineContainer = document.getElementById('timeline-container');
      const shouldShowSignup = timelineContainer?.getAttribute('data-should-show-signup') === 'true';
      const totalVotes = parseInt(timelineContainer?.getAttribute('data-total-votes') || '0');
      
      let html = '<div class="border-2 border-black bg-white p-8 text-center mono mb-4">' +
        '<p class="text-gray-600 mb-2">[ votaste todas las noticias ]</p>' +
        '<p class="text-xs text-gray-500 mb-4">¬°Bien hecho! Volv√© m√°s tarde para ver nuevas noticias.</p>' +
        '<a href="?filter=todas" class="border-2 border-black px-4 py-2 hover:bg-black hover:text-white inline-block">ver todas las noticias</a>' +
        '</div>';
      
      // Add signup prompt if conditions are met
      if (shouldShowSignup && totalVotes >= 3) {
        html += '<div id="signup-prompt-banner" ' +
          'class="fixed bottom-4 right-4 left-4 md:left-auto md:max-w-md z-50 ' +
          'bg-white border-4 border-black p-4 ' +
          'shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] ' +
          'animate-[slideUp_0.4s_ease-out]">' +
          '<button onclick="this.closest(\'#signup-prompt-banner\').remove()" ' +
          'class="absolute top-2 right-2 text-xl hover:text-gray-600 transition" aria-label="Cerrar">‚úï</button>' +
          '<div class="flex items-start gap-3 mb-3">' +
          '<div class="text-3xl">üó∫Ô∏è</div>' +
          '<div class="flex-1">' +
          '<p class="text-base mono font-bold mb-2">¬°Ya votaste en ' + totalVotes + ' noticias!</p>' +
          '<p class="text-xs mono text-gray-700 mb-3">Cre√° tu cuenta para desbloquear:</p>' +
          '<ul class="text-xs mono space-y-1.5 text-gray-700 mb-4">' +
          '<li class="flex items-start gap-2"><span class="text-green-600 font-bold">‚úì</span><span><strong>Guardar tus votos</strong> entre dispositivos</span></li>' +
          '<li class="flex items-start gap-2"><span class="text-green-600 font-bold">‚úì</span><span><strong>Tu alias</strong> en el mapa de opiniones</span></li>' +
          '<li class="flex items-start gap-2"><span class="text-green-600 font-bold">‚úì</span><span><strong>Email semanal</strong> con nuevas noticias</span></li>' +
          '</ul></div></div>' +
          '<div class="flex flex-col sm:flex-row gap-2">' +
          '<a href="/accounts/signup/?next=/" ' +
          'class="flex-1 text-center bg-black text-white px-4 py-2.5 text-sm mono font-bold border-2 border-black hover:bg-white hover:text-black transition-all">' +
          'Crear cuenta gratis</a>' +
          '<button onclick="this.closest(\'#signup-prompt-banner\').remove()" ' +
          'class="text-xs mono text-gray-600 hover:text-black underline">Seguir sin cuenta</button>' +
          '</div></div>';
      }
      
      container.innerHTML = html;
    }
  }

  document.body.addEventListener('htmx:afterSwap', function(event) {
    var target = event.detail.target;
    if (target && target.id && target.id.startsWith('noticia-')) {
      setTimeout(checkTimelineState, 1500);
    }
  });

  // Optimistic UI for voting - immediate feedback
  document.body.addEventListener('click', function(event) {
    const button = event.target.closest('.vote-button');
    if (button && button.type === 'submit') {
      const form = button.closest('.vote-form');
      if (form) {
        const opinion = button.getAttribute('data-opinion');
        const noticiaId = form.getAttribute('data-noticia-id');
        const currentFilter = '{{ current_filter|default:"" }}';
        
        // Track vote attempt
        trackEvent('vote-attempt', {
          opinion: opinion,
          noticia_id: noticiaId,
          filter: currentFilter,
          method: 'click'
        });
        
        // Store original state for potential revert
        if (!form.hasAttribute('data-original-state')) {
          form.setAttribute('data-original-state', JSON.stringify({
            buttons: Array.from(form.querySelectorAll('.vote-button')).map(btn => ({
              opinion: btn.getAttribute('data-opinion'),
              classes: btn.className
            }))
          }));
        }
        
        // Update buttons immediately (optimistic UI)
        form.querySelectorAll('.vote-button').forEach(btn => {
          const btnOpinion = btn.getAttribute('data-opinion');
          const emoji = btn.querySelector('.vote-emoji');
          const checkmark = btn.querySelector('.vote-checkmark');
          
          // Reset all buttons
          btn.className = btn.className
            .replace(/bg-(green|red|gray)-\d+|text-white|border-(green|red|gray)-\d+/g, '')
            .replace(/\s+/g, ' ')
            .trim() + ' border-2 border-black px-3 py-2 hover:bg-black hover:text-white transition-all duration-200 bg-white';
          
          checkmark.classList.add('hidden');
          
          // Highlight selected button
          if (btnOpinion === opinion) {
            if (opinion === 'buena') {
              btn.className += ' bg-green-600 text-white border-green-600';
            } else if (opinion === 'mala') {
              btn.className += ' bg-red-600 text-white border-red-600';
            } else {
              btn.className += ' bg-gray-500 text-white border-gray-500';
            }
            
            // Show checkmark briefly
            emoji.style.opacity = '0.7';
            checkmark.classList.remove('hidden');
            setTimeout(() => {
              checkmark.classList.add('hidden');
              emoji.style.opacity = '1';
            }, 800);
          }
        });
      }
    }
  }, true); // Use capture phase to run before HTMX

  // Revert on error
  document.body.addEventListener('htmx:responseError', function(event) {
    const form = event.detail.elt;
    if (form && form.classList.contains('vote-form')) {
      const noticiaId = form.getAttribute('data-noticia-id');
      const opinion = form.querySelector('.vote-button[class*="bg-"]')?.getAttribute('data-opinion');
      
      // Track vote error
      trackEvent('vote-error', {
        noticia_id: noticiaId,
        opinion: opinion,
        error: event.detail.xhr?.status || 'unknown'
      });
      
      const originalState = form.getAttribute('data-original-state');
      if (originalState) {
        try {
          const state = JSON.parse(originalState);
          const buttons = form.querySelectorAll('.vote-button');
          buttons.forEach((btn, idx) => {
            if (state.buttons[idx]) {
              btn.className = state.buttons[idx].classes;
            }
          });
        } catch (e) {
          console.error('[Memoria Web] Error reverting vote state:', e);
        }
      }
    }
  });

  // Swipe gestures for mobile voting (experimental)
  let touchStartX = 0;
  let touchEndX = 0;
  let touchStartY = 0;
  let touchEndY = 0;
  const SWIPE_THRESHOLD = 50; // minimum distance for swipe
  const SWIPE_MAX_VERTICAL = 30; // max vertical movement to consider horizontal swipe

  document.addEventListener('touchstart', function(e) {
    const noticiaCard = e.target.closest('[id^="noticia-"]');
    if (noticiaCard && window.innerWidth < 768) { // Only on mobile
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }
  }, { passive: true });

  document.addEventListener('touchend', function(e) {
    const noticiaCard = e.target.closest('[id^="noticia-"]');
    if (!noticiaCard || window.innerWidth >= 768) return;
    
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = Math.abs(touchEndY - touchStartY);
    
    // Only trigger if horizontal swipe and minimal vertical movement
    if (Math.abs(deltaX) > SWIPE_THRESHOLD && deltaY < SWIPE_MAX_VERTICAL) {
      const form = noticiaCard.querySelector('.vote-form');
      if (form) {
        let button;
        let opinion;
        if (deltaX > 0) {
          // Swipe right = buena
          button = form.querySelector('button[data-opinion="buena"]');
          opinion = 'buena';
        } else {
          // Swipe left = mala
          button = form.querySelector('button[data-opinion="mala"]');
          opinion = 'mala';
        }
        
        if (button) {
          const noticiaId = form.getAttribute('data-noticia-id');
          
          // Track swipe gesture
          trackEvent('vote-swipe', {
            opinion: opinion,
            noticia_id: noticiaId,
            direction: deltaX > 0 ? 'right' : 'left',
            distance: Math.abs(deltaX)
          });
          
          button.click();
          // Visual feedback
          noticiaCard.style.transform = 'translateX(' + (deltaX > 0 ? '10px' : '-10px') + ')';
          setTimeout(() => {
            noticiaCard.style.transform = '';
          }, 200);
        }
      }
    }
  }, { passive: true });

  // Update vote progress in bubble badge
  function updateVoteProgress() {
    // Get total votes from timeline container
    const timelineContainer = document.getElementById('timeline-container');
    const totalVotes = parseInt(timelineContainer?.getAttribute('data-total-votes') || '0');
    
    // Update mobile ticker with vote count
    const mobileTickerInfo = document.getElementById('mobile-ticker-info');
    if (mobileTickerInfo) {
      const currentText = mobileTickerInfo.getAttribute('data-total-votes') || '0';
      const newTotalVotes = totalVotes > 0 ? totalVotes : parseInt(currentText);
      mobileTickerInfo.setAttribute('data-total-votes', newTotalVotes);
      
      // Update text if cluster info exists
      if (mobileTickerInfo.textContent.includes('#')) {
        const parts = mobileTickerInfo.textContent.split(' | ');
        const hasVotos = parts.some(p => p.includes('votos'));
        if (!hasVotos && newTotalVotes > 0) {
          mobileTickerInfo.textContent = mobileTickerInfo.textContent.replace(
            /(\d+\.\d+)$/,
            '$1 | ' + newTotalVotes + ' votos'
          );
        } else if (hasVotos) {
          mobileTickerInfo.textContent = mobileTickerInfo.textContent.replace(
            /\d+ votos/,
            newTotalVotes + ' votos'
          );
        }
      }
    }
    
    // Update desktop badge expanded state
    const voteCountBadge = document.getElementById('badge-vote-count');
    if (voteCountBadge) {
      voteCountBadge.textContent = totalVotes > 0 ? totalVotes : voteCountBadge.getAttribute('data-total-votes') || '0';
      voteCountBadge.setAttribute('data-total-votes', totalVotes);
    }
  }

  // Update vote progress after vote
  document.body.addEventListener('htmx:afterSwap', function(event) {
    const target = event.detail.target;
    if (target && (target.classList.contains('vote-form') || target.id?.startsWith('noticia-') || target.id?.startsWith('vote-area-'))) {
      // Track successful vote
      const form = target.closest('.vote-form') || document.querySelector('.vote-form');
      if (form) {
        const noticiaId = form.getAttribute('data-noticia-id');
        const opinion = form.querySelector('.vote-button[class*="bg-"]')?.getAttribute('data-opinion');
        const currentFilter = '{{ current_filter|default:"" }}';
        
        trackEvent('vote-success', {
          opinion: opinion,
          noticia_id: noticiaId,
          filter: currentFilter,
          total_votes: parseInt(document.getElementById('timeline-container')?.getAttribute('data-total-votes') || '0') + 1
        });
      }
      
      // Update timeline container data attribute if available
      const timelineContainer = document.getElementById('timeline-container');
      if (timelineContainer) {
        const currentVotes = parseInt(timelineContainer.getAttribute('data-total-votes') || '0');
        timelineContainer.setAttribute('data-total-votes', currentVotes + 1);
      }
      setTimeout(updateVoteProgress, 300);
    }
  });

  // Periodic bubble info update (every 30 seconds)
  var hasClusterInitially = {% if has_cluster %}true{% else %}false{% endif %};

  function updateBubbleInfo() {
    fetch('{% url "api-voter-cluster" %}')
      .then(response => {
        if (!response.ok) {
          if (response.status === 404) return null;
          throw new Error('API error: ' + response.status);
        }
        return response.json();
      })
      .then(data => {
        if (!data) return;

        if (data.cluster_id !== null && data.cluster_id !== undefined) {
          const badge = document.getElementById('bubble-badge-desktop');
          if (badge && !badge.classList.contains('md:block')) {
            badge.classList.add('md:block');
          }

          const mobileTicker = document.getElementById('bubble-ticker-mobile');
          if (mobileTicker && mobileTicker.classList.contains('hidden')) {
            mobileTicker.classList.remove('hidden');
          }

          const mobileTickerInfo = document.getElementById('mobile-ticker-info');
          if (mobileTickerInfo) {
            const namePart = data.cluster_name ? data.cluster_name + ' | ' : '';
            const consensusValue = data.cluster_consensus !== null
              ? data.cluster_consensus : 0;
            const consensus = consensusValue.toFixed(1).replace(',', '.');
            mobileTickerInfo.textContent = namePart + '#' + data.cluster_id +
              ' | ' + data.cluster_size + 'v | ' + consensus;
          }

          const badgeId = document.getElementById('badge-cluster-id');
          if (badgeId) badgeId.textContent = '#' + data.cluster_id;

          const badgeName = document.getElementById('badge-cluster-name');
          if (badgeName) {
            if (data.cluster_name) {
              badgeName.textContent = data.cluster_name;
              badgeName.classList.remove('hidden');
            }
          }

          const expandedId = document.getElementById('badge-expanded-id');
          if (expandedId) expandedId.textContent = '#' + data.cluster_id;

          const nameSection = document.getElementById('badge-expanded-name-section');
          const expandedName = document.getElementById('badge-expanded-name');
          if (nameSection && expandedName) {
            if (data.cluster_name) {
              expandedName.textContent = data.cluster_name;
              nameSection.style.display = 'block';
            }
          }

          const expandedSize = document.getElementById('badge-expanded-size');
          if (expandedSize) expandedSize.textContent = data.cluster_size;

          const expandedConsensus = document.getElementById('badge-expanded-consensus');
          if (expandedConsensus) {
            const consensusValue = data.cluster_consensus !== null
              ? data.cluster_consensus : 0;
            expandedConsensus.textContent = consensusValue.toFixed(2).replace(',', '.');
          }

          // Enable the "mi burbuja" filter button if it was disabled
          const burbujaBtn = document.querySelector(
            'button[hx-get*="cluster_consenso_buena"]'
          );
          if (burbujaBtn && burbujaBtn.disabled) {
            burbujaBtn.disabled = false;
            burbujaBtn.classList.remove('opacity-50', 'cursor-not-allowed');
          }

          const noClusterMsg = document.getElementById('no-cluster-message');
          if (noClusterMsg) noClusterMsg.style.display = 'none';

          // Apply bubble colors (function from _bubble_badge.html)
          if (typeof applyBubbleColors === 'function') {
            applyBubbleColors(data.cluster_id);
          }
          
          // Update vote progress
          updateVoteProgress();
        }
      })
      .catch(error => {
        console.error('[Memoria Web] Error updating bubble info:', error);
      });
  }

  setInterval(updateBubbleInfo, 30000);

  if (!hasClusterInitially) {
    setTimeout(updateBubbleInfo, 2000);
  }
  
  // Initial vote progress update
  setTimeout(updateVoteProgress, 1000);

  // Share functionality - optimized for WhatsApp
  function shareTimeline() {
    const filterDescription = document.getElementById('active-filter-text')?.textContent?.replace('> ', '') || 'noticias nuevas';
    
    // Get filter params from URL
    const urlParams = new URLSearchParams(window.location.search);
    const filter = urlParams.get('filter') || '';
    const entidad = urlParams.get('entidad') || '';
    
    // Build share URL with current filters
    let shareUrl = window.location.origin + window.location.pathname;
    if (filter || entidad) {
      const params = [];
      if (filter) params.push('filter=' + filter);
      if (entidad) params.push('entidad=' + entidad);
      shareUrl += '?' + params.join('&');
    }
    
    // Track share event
    trackEvent('share-timeline', {
      filter: filter || 'none',
      entidad: entidad || 'none',
      url: shareUrl,
      method: 'whatsapp'
    });
    
    // Compose viral message for WhatsApp (optimized for engagement)
    let message = `üóûÔ∏è *memoria.uy*\n\nVot√° noticias uruguayas y descubr√≠ en qu√© burbuja est√°s.\n\n`;
    
    // Add context about what they're viewing with personalized messages
    if (filter || entidad) {
      if (filter === 'buena_mi') {
        message += `Estoy viendo las *buenas noticias* que vot√©. ¬øCoincidimos? ü§î\n\n`;
      } else if (filter === 'mala_mi') {
        message += `Estoy viendo las *malas noticias* que vot√©. ¬øPens√°s igual? ü§î\n\n`;
      } else if (filter === 'cluster_consenso_buena') {
        message += `Estoy viendo las noticias que *mi burbuja* considera buenas. ¬øEst√°s en la misma? ü´ß\n\n`;
      } else if (filter === 'buena_mayoria') {
        message += `Estoy viendo noticias que *la mayor√≠a* considera buenas. ¬øVos tambi√©n? üìä\n\n`;
      } else if (filter === 'mala_mayoria') {
        message += `Estoy viendo noticias que *la mayor√≠a* considera malas. ¬øCoincid√≠s? üìä\n\n`;
      } else if (filter.startsWith('mencionan_')) {
        message += `Estoy viendo: *${filterDescription}*\n\n`;
      } else {
        message += `Estoy viendo: *${filterDescription}*\n\n`;
      }
    } else {
      message += `Estoy viendo *noticias nuevas* para votar.\n\n`;
    }
    
    message += `${shareUrl}\n\n`;
    message += `¬øQu√© pens√°s de estas noticias? Votalas y descubr√≠ si est√°s en la misma burbuja que yo ü´ß`;
    
    shareToWhatsApp(message, shareUrl);
  }

  function shareNoticia(slug, title, description, detailUrl) {
    const shareUrl = window.location.origin + detailUrl;
    const shortDescription = description ? description.substring(0, 120).trim() : '';
    
    // Track share event
    trackEvent('share-noticia', {
      slug: slug,
      url: shareUrl,
      method: 'whatsapp'
    });
    
    // Compose viral message optimized for WhatsApp
    let message = `üì∞ *${title}*\n\n`;
    
    if (shortDescription) {
      message += `${shortDescription}\n\n`;
    }
    
    message += `¬øQu√© pens√°s de esta noticia?\n\n`;
    message += `Votala en memoria.uy y descubr√≠ c√≥mo la est√°n votando otras burbujas:\n\n`;
    message += `${shareUrl}`;
    
    shareToWhatsApp(message, shareUrl);
  }

  function shareToWhatsApp(message, url) {
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    // Combine message and URL for Web Share API
    const fullMessage = message.includes(url) ? message : message + '\n\n' + url;
    
    // Try Web Share API first (mobile native - opens WhatsApp directly on mobile)
    if (navigator.share && isMobile) {
      const shareData = {
        text: fullMessage
      };
      
      // Check if we can share (some browsers require url separately)
      if (navigator.canShare && navigator.canShare({ text: fullMessage, url: url })) {
        shareData.url = url;
      }
      
      navigator.share(shareData)
      .then(() => {
        console.log('[Memoria Web] Shared successfully via Web Share API');
      })
      .catch((error) => {
        if (error.name !== 'AbortError') {
          console.log('[Memoria Web] Web Share API failed, falling back to WhatsApp web:', error);
          // Fallback to WhatsApp web
          fallbackToWhatsAppWeb(fullMessage);
        }
      });
    } else {
      // Desktop or no Web Share API: use WhatsApp web
      fallbackToWhatsAppWeb(fullMessage);
    }
  }

  function fallbackToWhatsAppWeb(message) {
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
    window.open(whatsappUrl, '_blank', 'noopener,noreferrer');
  }

  // Intelligent preloading for infinite scroll
  let preloadObserver = null;
  let preloadCache = new Map();
  let isPreloading = false;

  function setupPreloading() {
    const loadMoreTrigger = document.getElementById('load-more-trigger');
    if (!loadMoreTrigger || isPreloading) return;

    // Create a preload trigger element that appears earlier (at 80% of scroll to trigger)
    const preloadElement = document.createElement('div');
    preloadElement.id = 'preload-trigger';
    preloadElement.className = 'h-1 w-full';
    preloadElement.style.position = 'absolute';
    preloadElement.style.top = '80%';
    preloadElement.style.pointerEvents = 'none';
    preloadElement.style.visibility = 'hidden';
    
    const timelineItems = document.getElementById('timeline-items');
    if (timelineItems && loadMoreTrigger.parentElement) {
      loadMoreTrigger.parentElement.style.position = 'relative';
      loadMoreTrigger.parentElement.insertBefore(preloadElement, loadMoreTrigger);
    }

    // Setup intersection observer for preloading
    preloadObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && loadMoreTrigger && !isPreloading) {
          const nextPage = loadMoreTrigger.getAttribute('data-next-page');
          const currentFilter = loadMoreTrigger.getAttribute('data-current-filter');
          const entityFilter = loadMoreTrigger.getAttribute('data-entity-filter');
          
          if (nextPage) {
            const cacheKey = `${nextPage}-${currentFilter}-${entityFilter}`;
            
            // Check if already cached
            if (preloadCache.has(cacheKey)) {
              return;
            }
            
            isPreloading = true;
            
            // Preload next page in background
            const url = '{% url "timeline" %}?page=' + nextPage;
            const params = [];
            if (currentFilter) params.push('filter=' + currentFilter);
            if (entityFilter) params.push('entidad=' + entityFilter);
            const fullUrl = url + (params.length ? '&' + params.join('&') : '');
            
            // Prefetch the URL (browser will cache it)
            const link = document.createElement('link');
            link.rel = 'prefetch';
            link.href = fullUrl;
            document.head.appendChild(link);
            
            // Also fetch and cache the HTML content
            fetch(fullUrl, {
              headers: {
                'HX-Request': 'true',
                'HX-Target': 'timeline-items'
              }
            })
            .then(response => {
              if (response.ok) {
                return response.text();
              }
              throw new Error('Preload failed');
            })
            .then(html => {
              // Cache the preloaded content
              preloadCache.set(cacheKey, html);
              isPreloading = false;
              
              // Cleanup prefetch link
              link.remove();
            })
            .catch(error => {
              console.error('[Memoria Web] Preload error:', error);
              isPreloading = false;
              link.remove();
            });
          }
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '300px' // Start preloading 300px before reaching trigger
    });

    if (preloadElement.parentElement) {
      preloadObserver.observe(preloadElement);
    }
  }

  // Use preloaded content when actual trigger is reached (if available)
  document.body.addEventListener('htmx:beforeRequest', function(event) {
    const trigger = event.detail.elt;
    if (trigger && trigger.id === 'load-more-trigger') {
      const nextPage = trigger.getAttribute('data-next-page');
      const currentFilter = trigger.getAttribute('data-current-filter');
      const entityFilter = trigger.getAttribute('data-entity-filter');
      const cacheKey = `${nextPage}-${currentFilter}-${entityFilter}`;
      
      if (preloadCache.has(cacheKey)) {
        const preloadedContent = preloadCache.get(cacheKey);
        preloadCache.delete(cacheKey); // Use once
        
        // Let HTMX handle the request normally, but it should be faster due to browser cache
        // The prefetch link we added should help with this
      }
    }
  });

  // Setup preloading when page loads or after new items are added
  function initPreloading() {
    setTimeout(() => {
      setupPreloading();
    }, 500);
  }

  // Initialize on page load
  initPreloading();

  // Re-initialize after HTMX swaps
  document.body.addEventListener('htmx:afterSwap', function(event) {
    const target = event.detail.target;
    if (target && (target.id === 'load-more-trigger' || target.closest('#load-more-trigger'))) {
      // Track infinite scroll page load
      const urlParams = new URLSearchParams(window.location.search);
      trackEvent('infinite-scroll', {
        page: urlParams.get('page') || '2',
        filter: urlParams.get('filter') || 'none',
        entidad: urlParams.get('entidad') || 'none'
      });
      
      // Cleanup old observer
      if (preloadObserver) {
        preloadObserver.disconnect();
        preloadObserver = null;
      }
      const oldPreloadTrigger = document.getElementById('preload-trigger');
      if (oldPreloadTrigger) {
        oldPreloadTrigger.remove();
      }
      isPreloading = false;
      
      // Setup new preloading for next page
      setTimeout(() => {
        setupPreloading();
      }, 300);
    }
  });
</script>
