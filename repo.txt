./manage.py
---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "memoria.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


---
./pyproject.toml
---
[tool.poetry]
name = "memoria"
version = "0.1.0"
description = ""
authors = ["raulsperoni <raulsperoni@gmail.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"
django = "^5.1.6"
celery = "^5.4.0"
djangorestframework = "^3.15.2"
dj-database-url = "^2.3.0"
psycopg2-binary = "^2.9.10"
supabase = "^2.13.0"
requests = "^2.32.3"
bs4 = "^0.0.2"
django-allauth = "^65.4.1"
dotenv = "^0.9.9"


[tool.poetry.group.dev.dependencies]
ipykernel = "^6.29.5"
files-to-prompt = "^0.6"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"


---
./core/__init__.py
---


---
./core/admin.py
---
from django.contrib import admin

# Register your models here.
from .models import Noticia, Voto

admin.site.register(Noticia)
admin.site.register(Voto)


---
./core/apps.py
---
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"


---
./core/archive.py
---
import requests
import re
from bs4 import BeautifulSoup


ARCHIVE_PH_SUBMIT_URL = "https://archive.ph/submit/"


class ArchiveInProgress(Exception):
    pass


class ArchiveFailure(Exception):
    pass


def capture(url, user_agent="Mozilla/5.0 (compatible; MyApp/1.0)"):
    """
    Capture the given URL using archive.ph.
    Returns the final archive URL or raises an Exception.
    """
    headers = {"User-Agent": user_agent}
    # Some minimal data; the archive service expects a "url" parameter.
    data = {"url": url, "submitid": "1"}
    response = requests.post(
        ARCHIVE_PH_SUBMIT_URL, data=data, headers=headers, timeout=30
    )

    # If the response is a redirect, assume the archive URL is in the Location header.
    if response.status_code == 302 and "Location" in response.headers:
        archive_url = response.headers["Location"]
        if archive_url == "https://archive.ph/wip":
            raise ArchiveInProgress(f"Archiving in progress for {url}")
        return archive_url, get_archive_details(response.text), response.text

    # Otherwise, try to extract the archive URL from the HTML using regex.
    match = re.search(r"(https?://archive\.ph/\w+)", response.text)
    if match:
        archive_url = match.group(1)
        if archive_url == "https://archive.ph/wip":
            raise ArchiveInProgress(f"Archiving in progress for {url}")
        return archive_url, get_archive_details(response.text), response.text

    raise ArchiveFailure(
        f"Failed to capture {url} via archive.ph (status: {response.status_code})"
    )


def get_archive_details(html):
    """
    Given an archive.ph URL, fetch the page and parse:
      - page title (from the <title> tag),
      - archive date (from a meta tag if available),
      - screenshot URL (from og:image meta tag)
    Returns a dict with these details.
    """

    soup = BeautifulSoup(html, "html.parser")

    # Parse the page title.
    page_title = soup.title.string.strip() if soup.title else None

    # Try to get archive date from a meta tag (this may vary depending on archive.ph's HTML).
    archive_date = None
    meta_date = soup.find("meta", attrs={"property": "article:published_time"})
    if meta_date and meta_date.get("content"):
        archive_date = meta_date["content"]

    # Parse screenshot URL from the Open Graph image meta tag.
    screenshot_url = None
    meta_img = soup.find("meta", attrs={"property": "og:image"})
    if meta_img and meta_img.get("content"):
        screenshot_url = meta_img["content"]

    url = soup.find("meta", attrs={"property": "og:url"})
    if url and url.get("content"):
        url = url["content"]

    return {
        "title": page_title,
        "archive_date": archive_date,
        "screenshot_url": screenshot_url,
        "archive_url": url,
    }


---
./core/forms.py
---
# forms.py

from django import forms

VOTE_CHOICES = [
    ("buena", "Buena noticia"),
    ("mala", "Mala noticia"),
    ("neutral", "Neutral"),
]


class NoticiaForm(forms.Form):
    opinion = forms.ChoiceField(choices=VOTE_CHOICES, label="Your Vote")
    enlace = forms.URLField(
        label="Pega el enlace de la noticia aquí",
        widget=forms.URLInput(
            attrs={
                "class": "w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
                "placeholder": "Pega el enlace de la noticia aquí",
            }
        ),
    )


---
./core/models.py
---
# models.py

from django.db import models
from django.contrib.auth.models import User
from core import archive
import logging
from bs4 import BeautifulSoup
import requests

logger = logging.getLogger(__name__)


class Noticia(models.Model):
    titulo = models.CharField(max_length=255, null=True)
    enlace = models.URLField(unique=True)
    archivo_url = models.URLField(blank=True, null=True)
    archivo_fecha = models.DateTimeField(blank=True, null=True)
    archivo_imagen = models.URLField(blank=True, null=True)
    fuente = models.CharField(max_length=255, null=True)
    categoria = models.CharField(
        max_length=100,
        choices=[
            ("politica", "Política"),
            ("economia", "Economía"),
            ("seguridad", "Seguridad"),
            ("salud", "Salud"),
            ("educacion", "Educación"),
            ("otros", "Otros"),
        ],
    )
    resumen = models.TextField(blank=True, null=True)
    agregado_por = models.ForeignKey(User, on_delete=models.CASCADE)
    fecha_agregado = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        if self.titulo:
            return self.titulo
        return self.enlace

    def get_title_from_meta_tags(self):
        try:
            headers = {
                "User-Agent": (
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/90.0.4430.93 Safari/537.36"
                )
            }

            response = requests.get(self.enlace, headers=headers)
            soup = BeautifulSoup(response.text, "html.parser")

            # Extract Open Graph meta tags
            og_title = soup.find("meta", property="og:title")
            og_image = soup.find("meta", property="og:image")

            title = og_title["content"] if og_title else "No title found"
            image = og_image["content"] if og_image else "No image found"
            logger.warning(f"Title: {title}, Image: {image}")
            self.titulo = title
            self.archivo_imagen = image

        except Exception as e:
            logger.error(f"Error getting title from meta tags: {e}")

    def get_archive(self):
        try:
            archive_url, archive_metadata, html = archive.capture(self.enlace)
            self.archivo_url = archive_url
            self.archivo_imagen = archive_metadata.get("screenshot_url")
            self.archivo_fecha = archive_metadata.get("archive_date")
            self.titulo = archive_metadata.get("title")
            logger.info(f"Archived {self.enlace} to {archive_url}")
            from core.tasks import parse

            parse.delay(self.id, html)
        except archive.ArchiveInProgress as e:
            logger.warning(e)
        except archive.ArchiveFailure as e:
            logger.error(e)
        except Exception as e:
            logger.error(
                f"Error archiving {self.enlace if 'noticia' in locals() else ''}: {e}"
            )

    def save(self, *args, **kwargs):
        # Save the object first so we have an ID
        if not self.archivo_url:
            self.get_archive()
        super().save(*args, **kwargs)


class Voto(models.Model):
    usuario = models.ForeignKey(User, on_delete=models.CASCADE)
    noticia = models.ForeignKey(Noticia, on_delete=models.CASCADE, related_name="votos")
    opinion = models.CharField(
        max_length=10,
        choices=[
            ("buena", "Buena noticia"),
            ("mala", "Mala noticia"),
            ("neutral", "Neutral"),
        ],
    )
    fecha_voto = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("usuario", "noticia")

    def __str__(self):
        return f"{self.usuario.username} - {self.opinion} - {self.noticia.titulo}"


class Entidad(models.Model):
    nombre = models.CharField(max_length=255)
    tipo = models.CharField(
        max_length=100,
        choices=[
            ("persona", "Persona"),
            ("organizacion", "Organización"),
            ("lugar", "Lugar"),
            ("otro", "Otro"),
        ],
    )

    def __str__(self):
        return self.nombre


class NoticiaEntidad(models.Model):
    noticia = models.ForeignKey(
        Noticia, on_delete=models.CASCADE, related_name="entidades"
    )
    entidad = models.ForeignKey(Entidad, on_delete=models.CASCADE)
    sentimiento = models.CharField(
        max_length=10,
        choices=[
            ("positivo", "Positivo"),
            ("negativo", "Negativo"),
            ("neutral", "Neutral"),
        ],
    )

    class Meta:
        unique_together = ("noticia", "entidad")

    def __str__(self):
        return f"{self.noticia.titulo} -{self.entidad.nombre}"


---
./core/parse.py
---
from typing import Optional, Literal, Union
from pydantic import BaseModel, Field
from litellm import completion
from bs4 import BeautifulSoup
import logging

# litellm._turn_on_debug()
logger = logging.getLogger(__name__)


def remove_unnecessary_tags(html):
    soup = BeautifulSoup(html, "html.parser")
    # remove all attrs except id
    for tag in soup(True):
        tag.attrs = {"id": tag.get("id", "")}
    soup = soup.find("div", id="CONTENT")

    if soup is None:
        return ""

    for tag in soup(
        [
            "script",
            "style",
            "img",
            "video",
            "audio",
            "iframe",
            "noscript",
            "old-meta",
            "old-script",
            "link",
        ]
    ):
        tag.decompose()
    # remove all styles, classes, and empty tags
    for tag in soup(True):
        if tag.name == "style" or not tag.text.strip():
            tag.decompose()
        else:
            tag.attrs = {}

    return str(soup)


class EntidadNombrada(BaseModel):
    nombre: str = Field(alias="nombre")
    tipo: Literal["persona", "organizacion", "lugar", "otro"]
    sentimiento: Literal["positivo", "negativo", "neutral"]


class Articulo(BaseModel):
    titulo: str = Field(alias="titulo", description="The title of the article.")
    fuente: str = Field(alias="fuente", description="The name of the news source.")
    categoria: Optional[
        Literal["politica", "economia", "seguridad", "salud", "educacion", "otros"]
    ] = Field(None, description="The category of the article.")
    autor: Optional[str] = Field(None, description="The author of the article.")
    resumen: Optional[str] = Field(None, description="A brief summary of the article.")
    entidades: Optional[list[EntidadNombrada]] = Field(None, alias="entidades")


def parse_noticia(html) -> Union[Articulo, None]:
    """
    Return the parsed article from the given HTML content.
    """
    try:
        clean_html = remove_unnecessary_tags(html)
        response = completion(
            model="openrouter/openai/o3-mini",  # "",
            caching=True,
            response_format=Articulo,
            messages=[
                {
                    "role": "system",
                    "content": "You are a helpful html parser designed to output JSON.",
                },
                {
                    "role": "user",
                    "content": f"""From the crawled content, metadata about the news article should be extracted.
                The metadata should include the title, source, category, author, and entities mentioned in the article.
                The entities should include the name, type, and sentiment of each entity.
                The HTML content to parse is as follows:
                
                {clean_html}""",
                },
            ],
        )
        article_data = response.choices[0].message.content
        logger.debug(article_data)
        return Articulo.parse_raw(article_data)
    except Exception as e:
        logger.error(f"Error parsing the article: {e}")
        return None


---
./core/tasks.py
---
from celery import shared_task
from celery.utils.log import get_task_logger
from core.parse import parse_noticia
from core.models import Noticia, Entidad, NoticiaEntidad

logger = get_task_logger(__name__)


@shared_task
def parse(noticia_id, html):
    noticia = Noticia.objects.get(id=noticia_id)
    logger.info(f"Parsing {noticia.enlace}")
    articulo = parse_noticia(html)
    if not articulo:
        logger.error(f"Failed to parse {noticia.enlace}")
        return
    noticia.fuente = articulo.fuente
    noticia.categoria = articulo.categoria if articulo.categoria else "otros"
    noticia.resumen = articulo.resumen
    noticia.save()
    logger.info(f"Parsed {noticia.enlace}")
    for entidad_nombrada in articulo.entidades:
        logger.info(f"Found entity {entidad_nombrada}")
        entidad, _ = Entidad.objects.get_or_create(
            nombre=entidad_nombrada.nombre, tipo=entidad_nombrada.tipo
        )
        NoticiaEntidad.objects.get_or_create(
            noticia=noticia,
            entidad=entidad,
            defaults={"sentimiento": entidad_nombrada.sentimiento},
        )
    logger.info(f"Entities saved for  {noticia.enlace}")
    return noticia_id


---
./core/tests.py
---
from django.test import TestCase

# Create your tests here.


---
./core/views.py
---
# views.py

from django.views.generic import ListView, View, FormView
from django.shortcuts import get_object_or_404, render
from django.http import HttpResponseBadRequest
from django.contrib.auth.mixins import LoginRequiredMixin
from core.models import Noticia, Voto
from core.forms import NoticiaForm
from django.urls import reverse_lazy
from django.shortcuts import redirect
from django.db.models import Count, Q, F


class NewsTimelineView(ListView):
    model = Noticia
    template_name = "noticias/timeline.html"
    context_object_name = "noticias"
    ordering = ["-fecha_agregado"]
    paginate_by = 10  # Adjust the number as needed

    def get_queryset(self):
        queryset = super().get_queryset()
        filter_param = self.request.GET.get("filter")
        if filter_param == "buena_mi" and self.request.user.is_authenticated:
            # Filter by good news by this user.
            queryset = queryset.filter(
                votos__usuario=self.request.user, votos__opinion="buena"
            )
        elif filter_param == "mala_mi" and self.request.user.is_authenticated:
            # Filter by bad news by this user.
            queryset = queryset.filter(
                votos__usuario=self.request.user, votos__opinion="mala"
            )
        elif filter_param == "buena_mayoria":
            # Filter by news with a majority of good votes.
            queryset = queryset.annotate(
                good_count=Count("votos", filter=Q(votos__opinion="buena"))
            ).filter(good_count__gt=F("votos__count") / 2)
        elif filter_param == "mala_mayoria":
            # Filter by news with a majority of bad votes.
            queryset = queryset.annotate(
                bad_count=Count("votos", filter=Q(votos__opinion="mala"))
            ).filter(bad_count__gt=F("votos__count") / 2)
        # You can add additional filter conditions here as the filter bar grows.
        return queryset

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Only include the form in the initial full-page load.
        if not self.request.headers.get("HX-Request"):
            context["form"] = NoticiaForm()
        return context

    def render_to_response(self, context, **response_kwargs):
        # If the request is via HTMX, return just the list items partial.
        if self.request.headers.get("HX-Request"):
            self.template_name = "noticias/timeline_items.html"
        return super().render_to_response(context, **response_kwargs)


class VoteView(LoginRequiredMixin, View):
    def post(self, request, pk):
        noticia = get_object_or_404(Noticia, pk=pk)
        opinion = request.POST.get("opinion")
        if opinion not in ["buena", "mala", "neutral"]:
            return HttpResponseBadRequest("Invalid vote")

        # Update or create the vote for this user.
        # (This allows a user to change their vote.)
        Voto.objects.update_or_create(
            usuario=request.user, noticia=noticia, defaults={"opinion": opinion}
        )
        # Render the updated vote area partial.
        context = {"noticia": noticia, "user": request.user}
        return render(request, "noticias/vote_area.html", context)


class NoticiaCreateView(LoginRequiredMixin, FormView):
    template_name = "noticias/timeline_fragment.html"  # This fragment includes both the form and the timeline
    form_class = NoticiaForm
    success_url = reverse_lazy("timeline")

    def form_valid(self, form):
        vote_opinion = form.cleaned_data.get("opinion")
        enlace = form.cleaned_data.get("enlace")
        try:
            # Try to retrieve an existing Noticia with this enlace.
            noticia = Noticia.objects.get(enlace=enlace)
            # Refresh its archive data.
            noticia.get_archive()
            noticia.save()
            # Update or create the vote for the current user.
            Voto.objects.update_or_create(
                usuario=self.request.user,
                noticia=noticia,
                defaults={"opinion": vote_opinion},
            )
        except Noticia.DoesNotExist:
            # Create a new Noticia if it doesn't exist.
            noticia = Noticia(
                agregado_por=self.request.user,
                enlace=enlace,
            )
            noticia.get_title_from_meta_tags()
            noticia.get_archive()
            noticia.save()
            Voto.objects.create(
                usuario=self.request.user,
                noticia=noticia,
                opinion=vote_opinion,
            )

        # For HTMX requests, re-render the entire timeline fragment (form and timeline).
        if self.request.headers.get("HX-Request"):
            noticias = Noticia.objects.all().order_by("-fecha_agregado")
            # Pass a fresh form instance so the fields are cleared.
            return render(
                self.request,
                "noticias/timeline_fragment.html",
                {"noticias": noticias, "form": self.get_form_class()()},
            )
        return redirect(self.success_url)


class RefreshNoticiaView(LoginRequiredMixin, View):
    def post(self, request, pk):
        noticia = get_object_or_404(Noticia, pk=pk)
        noticia.get_archive()
        noticia.save(
            update_fields=["archivo_url", "archivo_fecha", "archivo_imagen", "titulo"]
        )
        # Render the updated timeline item fragment.
        return render(request, "noticias/timeline_item.html", {"noticia": noticia})


---
./core/templatetags/vote_extras.py
---
from django import template

register = template.Library()


@register.filter
def vote_count(votos, opinion):
    """
    Given a queryset of votes and an opinion string, returns the count.
    Usage: {{ noticia.votos|vote_count:"buena" }}
    """
    return votos.filter(opinion=opinion).count()


---
./core/migrations/0001_initial.py
---
# Generated by Django 5.0 on 2025-02-18 21:32

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="Noticia",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("titulo", models.CharField(max_length=255)),
                ("enlace", models.URLField(unique=True)),
                ("archivo_url", models.URLField(blank=True, null=True)),
                ("fecha_publicacion", models.DateField()),
                ("fuente", models.CharField(max_length=255)),
                (
                    "categoria",
                    models.CharField(
                        choices=[
                            ("politica", "Política"),
                            ("economia", "Economía"),
                            ("salud", "Salud"),
                            ("educacion", "Educación"),
                            ("otros", "Otros"),
                        ],
                        max_length=100,
                    ),
                ),
                ("fecha_agregado", models.DateTimeField(auto_now_add=True)),
                (
                    "agregado_por",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="Voto",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "opinion",
                    models.CharField(
                        choices=[
                            ("buena", "Buena noticia"),
                            ("mala", "Mala noticia"),
                            ("neutral", "Neutral"),
                        ],
                        max_length=10,
                    ),
                ),
                ("fecha_voto", models.DateTimeField(auto_now_add=True)),
                (
                    "noticia",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="votos",
                        to="core.noticia",
                    ),
                ),
                (
                    "usuario",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "unique_together": {("usuario", "noticia")},
            },
        ),
    ]


---
./core/migrations/0002_noticia_archivo_fecha_noticia_archivo_imagen.py
---
# Generated by Django 5.0 on 2025-02-21 20:46

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="noticia",
            name="archivo_fecha",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name="noticia",
            name="archivo_imagen",
            field=models.URLField(blank=True, null=True),
        ),
    ]


---
./core/migrations/0003_remove_noticia_fecha_publicacion_and_more.py
---
# Generated by Django 5.1.6 on 2025-02-22 11:50

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("core", "0002_noticia_archivo_fecha_noticia_archivo_imagen"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="noticia",
            name="fecha_publicacion",
        ),
        migrations.AlterField(
            model_name="noticia",
            name="fuente",
            field=models.CharField(max_length=255, null=True),
        ),
        migrations.AlterField(
            model_name="noticia",
            name="titulo",
            field=models.CharField(max_length=255, null=True),
        ),
    ]


---
./core/migrations/0004_entidad_noticia_resumen_alter_noticia_categoria_and_more.py
---
# Generated by Django 5.1.6 on 2025-02-24 14:24

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("core", "0003_remove_noticia_fecha_publicacion_and_more"),
    ]
    operations = [
        migrations.CreateModel(
            name="Entidad",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("nombre", models.CharField(max_length=255)),
                (
                    "tipo",
                    models.CharField(
                        choices=[
                            ("persona", "Persona"),
                            ("organizacion", "Organización"),
                            ("lugar", "Lugar"),
                            ("otro", "Otro"),
                        ],
                        max_length=100,
                    ),
                ),
            ],
        ),
        migrations.AddField(
            model_name="noticia",
            name="resumen",
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name="noticia",
            name="categoria",
            field=models.CharField(
                choices=[
                    ("politica", "Política"),
                    ("economia", "Economía"),
                    ("seguridad", "Seguridad"),
                    ("salud", "Salud"),
                    ("educacion", "Educación"),
                    ("otros", "Otros"),
                ],
                max_length=100,
            ),
        ),
        migrations.CreateModel(
            name="NoticiaEntidad",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "sentimiento",
                    models.CharField(
                        choices=[
                            ("positivo", "Positivo"),
                            ("negativo", "Negativo"),
                            ("neutral", "Neutral"),
                        ],
                        max_length=10,
                    ),
                ),
                (
                    "entidad",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE, to="core.entidad"
                    ),
                ),
                (
                    "noticia",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="entidades",
                        to="core.noticia",
                    ),
                ),
            ],
            options={
                "unique_together": [("noticia", "entidad")],
            },
        ),
    ]


---
./core/migrations/__init__.py
---


---
./memoria/__init__.py
---
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ("celery_app",)


---
./memoria/asgi.py
---
"""
ASGI config for memoria project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "memoria.settings")

application = get_asgi_application()


---
./memoria/celery.py
---
import os
from celery import Celery

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "memoria.settings")
app = Celery(
    "memoria",
    broker_url="filesystem://",
    broker_transport_options={
        "data_folder_in": "./.data/broker",
        "data_folder_out": "./.data/broker/",
        "data_folder_processed": "./.data/broker/processed",
    },
    result_persistent=False,
    task_serializer="json",
    result_serializer="json",
    accept_content=["json"],
)
app.config_from_object("django.conf:settings", namespace="CELERY")
app.autodiscover_tasks()

for f in ["./broker/out", "./broker/processed"]:
    if not os.path.exists(f):
        os.makedirs(f)


---
./memoria/settings.py
---
import os
from pathlib import Path
import dj_database_url
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv("SECRET_KEY", "django-insecure-key")
DEBUG = os.getenv("DEBUG", "True") == "True"

ALLOWED_HOSTS = ["*"]

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "allauth",
    "allauth.account",
    "rest_framework",
    "core",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "allauth.account.middleware.AccountMiddleware",
]

ROOT_URLCONF = "memoria.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "django.template.context_processors.request",
            ],
        },
    },
]

WSGI_APPLICATION = "memoria.wsgi.application"

DATABASES = {
    "default": dj_database_url.config(
        default=f"sqlite:///{BASE_DIR / 'db.sqlite3'}"
        if DEBUG
        else os.getenv("SUPABASE_DATABASE_URL")
    )
}

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = "es-uy"
TIME_ZONE = "America/Montevideo"
USE_I18N = True
USE_TZ = True

STATIC_URL = "static/"
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Configuración de Django REST Framework
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework.authentication.SessionAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": (
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ),
}


LOGGING = {
    "version": 1,  # the dictConfig format version
    "disable_existing_loggers": False,  # retain the default loggers
}


AUTHENTICATION_BACKENDS = [
    # Needed to login by username in Django admin, regardless of `allauth`
    "django.contrib.auth.backends.ModelBackend",
    # `allauth` specific authentication methods, such as login by email
    "allauth.account.auth_backends.AuthenticationBackend",
]


---
./memoria/urls.py
---
"""
URL configuration for memoria project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

from django.contrib import admin
from django.urls import path, include
from core.views import NewsTimelineView, VoteView, NoticiaCreateView, RefreshNoticiaView

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", NewsTimelineView.as_view(), name="timeline"),
    path("vote/<int:pk>/", VoteView.as_view(), name="vote"),
    path("noticias/new/", NoticiaCreateView.as_view(), name="noticia-create"),
    path(
        "noticias/<int:pk>/refresh/",
        RefreshNoticiaView.as_view(),
        name="noticia-refresh",
    ),
    path("accounts/", include("allauth.urls")),
]


---
./memoria/wsgi.py
---
"""
WSGI config for memoria project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "memoria.settings")

application = get_wsgi_application()


---
